import xml.etree.ElementTree as ET  



def extract(path):
    tree = ET.parse(path)  
    root = tree.getroot()
    owls = dict()
    for item in root.iter('owl'):
            owls[int(item.attrib['id'])] = True
    return owls

a_path = "add your path to the file generated by user_mec"
e_angular = extract(a_path)

e_path = "add your path to the file generated by user_mec"
e_ember = extract(e_path)

v_path = "add your path to the file generated by user_mec"
e_vue = extract(v_path)

r_path = "add your path to the file generated by user_mec"
e_react = extract(r_path)



#This is a goog place to implement recursive calls using functional programming, later
def is_present(val,col):
    if val in col.keys():
        return True
    return False

def is_more_present(val,col,col2):
    if val in col.keys():
        if val in col2.keys():
            return True
    return False

def is_more_more_present(val,col,col2,col3):
    if val in col.keys():
        if val in col2.keys():
            if val in col3.keys():
                return True
    return False

# A-E, A-V, A-R, E-V, E-R, V-R in more than 1
def p2(a,b):
    return len(list(filter(lambda kv:is_present(kv[0],b),a.items())))

# # A-E-V, A-E-R, E-V-R In more than 2
def p3(a,b,c):
    return len(list(filter(lambda kv: is_more_present(kv[0],b,c),a.items())))


# # A-E-V-R In All
def p4(a,b,c,d):
    return len(list(filter(lambda kv:is_more_more_present(kv[0],b,c,d),a.items())))


print("A-E: ",p2(e_angular,e_ember))
print("A-V: ",p2(e_angular,e_vue))
print("A-R: ",p2(e_angular,e_react))
print("E-V: ",p2(e_ember,e_vue))
print("E-R: ",p2(e_ember,e_react))
print("V-R: ",p2(e_vue,e_react))

print("A-E-V: ",p3(e_angular,e_ember,e_vue))
print("A-E-R: ",p3(e_angular,e_ember,e_react))
print("A-V-R: ",p3(e_angular,e_vue,e_react))
print("E-V-R: ",p3(e_ember,e_vue,e_react))

print("A-E-V-R: ",p4(e_angular,e_ember,e_vue,e_react))
